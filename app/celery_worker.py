import os
import json
import redis
import requests
from google import genai
from google.genai import types
from celery import Celery
from celery.exceptions import MaxRetriesExceededError
from typing import Optional
import wave
import io
import urllib.parse

# --- Configuration ---
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
SETTINGS_KEY = "tts_settings"

redis_client = redis.from_url(REDIS_URL, decode_responses=True)

def load_settings():
    """Loads settings from Redis or environment variables."""
    settings_json = redis_client.get(SETTINGS_KEY)
    if settings_json:
        return json.loads(settings_json)
    else:
        return {
            "GEMINI_API_KEY": os.getenv("GEMINI_API_KEY", ""),
            "GEMINI_TTS_MODEL": os.getenv("GEMINI_TTS_MODEL", "gemini-2.5-flash-preview-tts"),
            "TTS_VOICE": os.getenv("TTS_VOICE", "Kore"),
            "TTS_PROMPT": os.getenv("TTS_PROMPT", ""),
            "SUCCESS_WEBHOOK_URL": os.getenv("SUCCESS_WEBHOOK_URL", ""),
            "ERROR_WEBHOOK_URL": os.getenv("ERROR_WEBHOOK_URL", ""),
            "CALLBACK_URL": os.getenv("CALLBACK_URL", ""),
        }

celery_app = Celery("app.celery_worker", broker=REDIS_URL)

@celery_app.task(bind=True, max_retries=3, default_retry_delay=60, acks_late=True)
def generate_audio_task(self, text: str, phone_number: str, short_text: Optional[str] = None):
    """
    Generates audio, sends it to a webhook, and then sends a secondary callback.
    """
    print(f"Starting audio generation task for: {phone_number} with short_text: {short_text}")
    settings = load_settings()
    
    try:
        api_key = settings.get("GEMINI_API_KEY")
        if not api_key:
            raise ValueError("API Key is not configured.")

        client = genai.Client(api_key=api_key)

        prompt = settings.get("TTS_PROMPT", "")
        full_content_prompt = f"{prompt}: {text}" if prompt else text
        
        print(f"Generating audio with full prompt: '{full_content_prompt}'")

        tts_config = types.GenerateContentConfig(
            response_modalities=["AUDIO"],
            speech_config=types.SpeechConfig(
                voice_config=types.VoiceConfig(
                    prebuilt_voice_config=types.PrebuiltVoiceConfig(
                        voice_name=settings.get("TTS_VOICE", "Kore"),
                    )
                )
            ),
        )

        response = client.models.generate_content(
            model=settings.get("GEMINI_TTS_MODEL"),
            contents=full_content_prompt,
            config=tts_config,
        )

        pcm_data = response.candidates[0].content.parts[0].inline_data.data
        if not pcm_data:
            raise ValueError("No audio data was generated by the API.")

        buffer = io.BytesIO()
        with wave.open(buffer, 'wb') as wf:
            wf.setnchannels(1)
            wf.setsampwidth(2)
            wf.setframerate(24000)
            wf.writeframes(pcm_data)
        wav_data = buffer.getvalue()

        success_webhook_url = settings.get("SUCCESS_WEBHOOK_URL")
        if success_webhook_url:
            dynamic_success_url = success_webhook_url.replace("{{PHONE_NUMBER}}", phone_number)
            file_name = f"{phone_number}.wav"
            files = {'file': (file_name, wav_data, 'audio/wav')}
            payload = {'phone_number': phone_number}

            print(f"Sending audio file to DYNAMIC success webhook: {dynamic_success_url}")
            post_response = requests.post(dynamic_success_url, files=files, data=payload, timeout=30)
            post_response.raise_for_status()
            print("Audio file sent successfully.")

        base_callback_url = settings.get("CALLBACK_URL")
        if base_callback_url and short_text:
            print(f"Preparing to send secondary callback for {phone_number}.")
            try:
                phones_dict = {phone_number: short_text}
                phones_json_string = json.dumps(phones_dict)
                encoded_phones_param = urllib.parse.quote(phones_json_string)
                
                separator = "&" if "?" in base_callback_url else "?"
                final_callback_url = f"{base_callback_url}{separator}phones={encoded_phones_param}"

                print(f"Sending callback to final URL: {final_callback_url}")
                callback_response = requests.post(final_callback_url, timeout=20)
                callback_response.raise_for_status()
                print(f"Callback for {phone_number} sent successfully.")

            except Exception as callback_exc:
                print(f"⚠️ WARNING: Failed to send callback for {phone_number}. Error: {callback_exc}")

        return {"status": "success", "phone_number": phone_number, "callback_sent": bool(base_callback_url and short_text)}

    except Exception as exc:
        print(f"Task for {phone_number} failed. Attempt {self.request.retries + 1} of {self.max_retries}. Error: {str(exc)}")
        try:
            self.retry(exc=exc)
        except MaxRetriesExceededError:
            print(f"Max retries exceeded for task {self.request.id} ({phone_number}). Sending error notification.")
            error_url = settings.get("ERROR_WEBHOOK_URL")
            if error_url:
                try:
                    error_payload = {
                        "task_id": self.request.id,
                        "phone_number": phone_number,
                        "error_message": f"Failed after {self.max_retries} retries: {str(exc)}"
                    }
                    requests.post(error_url, json=error_payload, timeout=10)
                except Exception as webhook_exc:
                    print(f"Failed to send error notification webhook: {str(webhook_exc)}")
            
            return {"status": "failed", "phone_number": phone_number, "error": str(exc)}