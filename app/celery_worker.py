import os
import json
import redis
import requests
import google.generativeai as genai
from celery import Celery
from celery.exceptions import MaxRetriesExceededError

# --- Configuration ---
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
SETTINGS_KEY = "tts_settings"

redis_client = redis.from_url(REDIS_URL, decode_responses=True)

def load_settings():
    """טוען הגדרות מ-Redis או ממשתני הסביבה כברירת מחדל"""
    settings_json = redis_client.get(SETTINGS_KEY)
    if settings_json:
        return json.loads(settings_json)
    else:
        # Fallback to environment variables
        return {
            "GEMINI_API_KEY": os.getenv("GEMINI_API_KEY", ""),
            "GEMINI_TTS_MODEL": os.getenv("GEMINI_TTS_MODEL", "tts-1"),
            "TTS_VOICE": os.getenv("TTS_VOICE", "echo"),
            "TTS_PROMPT": os.getenv("TTS_PROMPT", ""),
            "SUCCESS_WEBHOOK_URL": os.getenv("SUCCESS_WEBHOOK_URL", ""),
            "ERROR_WEBHOOK_URL": os.getenv("ERROR_WEBHOOK_URL", "")
        }

# Configure Celery
# The name 'app.celery_worker' should match the file path for auto-discovery
celery_app = Celery("app.celery_worker", broker=REDIS_URL)

@celery_app.task(bind=True, max_retries=3, default_retry_delay=60, acks_late=True)
def generate_audio_task(self, text: str, phone_number: str):
    """
    משימת Celery לייצור קובץ שמע באמצעות Gemini TTS ושליחתו דרך Webhook.
    המשימה מבצעת ניסיונות חוזרים במקרה של כישלון.
    """
    print(f"Starting audio generation task for: {phone_number}")
    
    settings = load_settings()
    
    try:
        # --- שלב 1: אימות הגדרות חיוניות ---
        api_key = settings.get("GEMINI_API_KEY")
        success_url = settings.get("SUCCESS_WEBHOOK_URL")
        if not api_key or not success_url:
            raise ValueError("API Key or Success Webhook URL are not configured.")

        genai.configure(api_key=api_key)

        # --- שלב 2: בניית הטקסט המלא עם הנחיית הסגנון ---
        prompt = settings.get("TTS_PROMPT", "")
        full_text = f"{prompt}: {text}" if prompt else text
        
        print(f"Generating audio for text: '{full_text}'")

        # --- שלב 3: קריאה נכונה ל-API של Gemini TTS ---
        # זוהי הדרך הנכונה לקרוא למודל TTS.
        # הפלט הוא אובייקט עם שדה 'audio_content' שמכיל את המידע הבינארי.
        response = genai.text_to_speech(
            model=settings.get("GEMINI_TTS_MODEL", "tts-1"),
            text=full_text,
            voice=settings.get("TTS_VOICE", "echo")
        )
        
        audio_data = response.audio_content
        
        if not audio_data:
            raise ValueError("No audio data was generated by the API.")

        # --- שלב 4: שליחת קובץ השמע ל-Webhook ---
        file_name = f"{phone_number}.mp3"
        files = {'file': (file_name, audio_data, 'audio/mpeg')}
        payload = {'phone_number': phone_number}

        print(f"Sending audio file to success webhook: {success_url}")
        post_response = requests.post(success_url, files=files, data=payload, timeout=30)
        post_response.raise_for_status() # יזרוק שגיאה אם סטטוס הקוד הוא 4xx או 5xx

        print(f"Task for {phone_number} completed successfully.")
        return {"status": "success", "phone_number": phone_number}

    except Exception as exc:
        print(f"Task for {phone_number} failed. Attempt {self.request.retries + 1} of {self.max_retries}. Error: {str(exc)}")
        try:
            # נסה לבצע את המשימה שוב, עם עיכוב
            self.retry(exc=exc)
        except MaxRetriesExceededError:
            # אם כל הניסיונות נכשלו, שלח התראת שגיאה
            print(f"Max retries exceeded for task {self.request.id} ({phone_number}). Sending error notification.")
            error_url = settings.get("ERROR_WEBHOOK_URL")
            if error_url:
                try:
                    error_payload = {
                        "task_id": self.request.id,
                        "phone_number": phone_number,
                        "original_text": text,
                        "error_message": f"Failed after {self.max_retries} retries: {str(exc)}"
                    }
                    requests.post(error_url, json=error_payload, timeout=10)
                except Exception as webhook_exc:
                    print(f"Failed to send error notification webhook: {str(webhook_exc)}")
            
            return {"status": "failed", "phone_number": phone_number, "error": str(exc)}