import os
import json
import redis
import requests
import wave 
import io
from google import genai
from google.genai import types
from celery import Celery
from celery.exceptions import MaxRetriesExceededError
from typing import Optional

# --- Configuration ---
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
SETTINGS_KEY = "tts_settings"

redis_client = redis.from_url(REDIS_URL, decode_responses=True)

def load_settings():
    """Loads settings from Redis or environment variables"""
    settings_json = redis_client.get(SETTINGS_KEY)
    if settings_json:
        return json.loads(settings_json)
    else:
        # Default settings pointing to the new models
        return {
            "GEMINI_API_KEY": os.getenv("GEMINI_API_KEY", ""),
            "GEMINI_TTS_MODEL": os.getenv("GEMINI_TTS_MODEL", "gemini-2.5-flash-preview-tts"),
            "TTS_VOICE": os.getenv("TTS_VOICE", "Kore"),
            "TTS_PROMPT": os.getenv("TTS_PROMPT", ""),
            "SUCCESS_WEBHOOK_URL": os.getenv("SUCCESS_WEBHOOK_URL", ""),
            "ERROR_WEBHOOK_URL": os.getenv("ERROR_WEBHOOK_URL", ""),
            "CALLBACK_URL": os.getenv("CALLBACK_URL", ""),
        }

celery_app = Celery("app.celery_worker", broker=REDIS_URL)

@celery_app.task(bind=True, max_retries=3, default_retry_delay=60, acks_late=True)
def generate_audio_task(self, text: str, phone_number: str, short_text: Optional[str] = None):
    """
    Celery task to generate audio, send it to a dynamic webhook, and then send a secondary callback.
    """
    print(f"Starting audio generation task for: {phone_number} with short_text: {'Yes' if short_text else 'No'}")
    settings = load_settings()
    
    try:
        api_key = settings.get("GEMINI_API_KEY")
        base_success_url = settings.get("SUCCESS_WEBHOOK_URL")
        if not api_key or not base_success_url:
            raise ValueError("API Key or Success Webhook URL are not configured.")

        # --- יצירת קובץ השמע (ללא שינוי) ---
        client = genai.Client(api_key=api_key)
        prompt = settings.get("TTS_PROMPT", "")
        full_content_prompt = f"{prompt}: {text}" if prompt else text
        
        print(f"Generating audio with full prompt: '{full_content_prompt}'")
        
        tts_config = types.GenerateContentConfig(
            response_modalities=["AUDIO"],
            speech_config=types.SpeechConfig(
                voice_config=types.VoiceConfig(
                    prebuilt_voice_config=types.PrebuiltVoiceConfig(
                        voice_name=settings.get("TTS_VOICE", "Kore"),
                    )
                )
            ),
        )
        
        response = client.models.generate_content(
            model=settings.get("GEMINI_TTS_MODEL"),
            contents=full_content_prompt,
            config=tts_config,
        )
        
        pcm_data = response.candidates[0].content.parts[0].inline_data.data
        if not pcm_data:
            raise ValueError("No audio data was generated by the API.")

        buffer = io.BytesIO()
        with wave.open(buffer, 'wb') as wf:
            wf.setnchannels(1)
            wf.setsampwidth(2)
            wf.setframerate(24000)
            wf.writeframes(pcm_data)
        
        wav_data = buffer.getvalue()

        # --- שליחת קובץ ה-WAV לכתובת דינמית ---
        dynamic_webhook_url = base_success_url.replace("{{PHONE_NUMBER}}", phone_number)
        
        file_name = f"{phone_number}.wav"
        files = {'file': (file_name, wav_data, 'audio/wav')}
        payload = {'phone_number': phone_number}

        print(f"Sending audio file to DYNAMIC success webhook: {dynamic_webhook_url}")
        post_response = requests.post(dynamic_webhook_url, files=files, data=payload, timeout=30)
        post_response.raise_for_status()

       print("Audio file sent successfully.")

  # --- ⬇️ לוגיקת Callback שונתה לחלוטין ⬇️ ---
        
        base_callback_url = settings.get("CALLBACK_URL")
        if base_callback_url and short_text:
            print(f"Preparing to send secondary callback for {phone_number}.")
            try:
                # 1. יצירת מילון פייתון עם הנתונים
                phones_dict = {phone_number: short_text}
                
                # 2. המרת המילון למחרוזת JSON
                phones_json_string = json.dumps(phones_dict)
                
                # 3. קידוד מחרוזת ה-JSON כדי שתהיה בטוחה לשימוש ב-URL
                encoded_phones_param = urllib.parse.quote(phones_json_string)
                
                # 4. בניית ה-URL הסופי על ידי הוספת הפרמטר המקודד
                # ודא שבכתובת הבסיסית אין `&` בסוף
                separator = "&" if "?" in base_callback_url else "?"
                final_callback_url = f"{base_callback_url}{separator}phones={encoded_phones_param}"

                # בקריאה הזו גוף הבקשה ריק, כי כל המידע נמצא בתוך ה-URL
                print(f"Sending callback to final URL: {final_callback_url}")
                callback_response = requests.post(final_callback_url, timeout=20)
                callback_response.raise_for_status()
                print(f"Callback for {phone_number} sent successfully.")

            except Exception as callback_exc:
                print(f"⚠️ WARNING: Failed to send callback for {phone_number}. Error: {callback_exc}")

        return {"status": "success", "phone_number": phone_number, "callback_sent": bool(base_callback_url and short_text)}

    except Exception as exc:       
        # --- לוגיקת טיפול בשגיאות (ללא שינוי) ---
        print(f"Task for {phone_number} failed. Attempt {self.request.retries + 1} of {self.max_retries}. Error: {str(exc)}")
        try:
            self.retry(exc=exc)
        except MaxRetriesExceededError:
            print(f"Max retries exceeded for task {self.request.id} ({phone_number}). Sending error notification.")
            error_url = settings.get("ERROR_WEBHOOK_URL")
            if error_url:
                try:
                    error_payload = {
                        "task_id": self.request.id,
                        "phone_number": phone_number,
                        "original_text": text,
                        "error_message": f"Failed after {self.max_retries} retries: {str(exc)}"
                    }
                    requests.post(error_url, json=error_payload, timeout=10)
                except Exception as webhook_exc:
                    print(f"Failed to send error notification webhook: {str(webhook_exc)}")
            
            return {"status": "failed", "phone_number": phone_number, "error": str(exc)}