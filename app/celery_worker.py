import os
import json
import redis
import requests
import wave 
import io
from google import genai
from google.genai import types
from celery import Celery
from celery.exceptions import MaxRetriesExceededError
from typing import Optional

# --- Configuration ---
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
SETTINGS_KEY = "tts_settings"

redis_client = redis.from_url(REDIS_URL, decode_responses=True)

def load_settings():
    """Loads settings from Redis or environment variables"""
    settings_json = redis_client.get(SETTINGS_KEY)
    if settings_json:
        return json.loads(settings_json)
    else:
        # Default settings pointing to the new models
        return {
            "GEMINI_API_KEY": os.getenv("GEMINI_API_KEY", ""),
            "GEMINI_TTS_MODEL": os.getenv("GEMINI_TTS_MODEL", "gemini-2.5-flash-preview-tts"),
            "TTS_VOICE": os.getenv("TTS_VOICE", "Kore"),
            "TTS_PROMPT": os.getenv("TTS_PROMPT", ""),
            "SUCCESS_WEBHOOK_URL": os.getenv("SUCCESS_WEBHOOK_URL", ""),
            "ERROR_WEBHOOK_URL": os.getenv("ERROR_WEBHOOK_URL", ""),
            "CALLBACK_URL": os.getenv("CALLBACK_URL", ""),
        }

celery_app = Celery("app.celery_worker", broker=REDIS_URL)

@celery_app.task(bind=True, max_retries=3, default_retry_delay=60, acks_late=True)
def generate_audio_task(self, text: str, phone_number: str, short_text: Optional[str] = None):
    """
    Celery task to generate audio, send it to a dynamic webhook, and then send a secondary callback.
    """
    print(f"Starting audio generation task for: {phone_number} with short_text: {'Yes' if short_text else 'No'}")
    settings = load_settings()
    
    try:
        api_key = settings.get("GEMINI_API_KEY")
        base_success_url = settings.get("SUCCESS_WEBHOOK_URL")
        if not api_key or not base_success_url:
            raise ValueError("API Key or Success Webhook URL are not configured.")

        # --- יצירת קובץ השמע (ללא שינוי) ---
        client = genai.Client(api_key=api_key)
        prompt = settings.get("TTS_PROMPT", "")
        full_content_prompt = f"{prompt}: {text}" if prompt else text
        
        print(f"Generating audio with full prompt: '{full_content_prompt}'")
        
        tts_config = types.GenerateContentConfig(
            response_modalities=["AUDIO"],
            speech_config=types.SpeechConfig(
                voice_config=types.VoiceConfig(
                    prebuilt_voice_config=types.PrebuiltVoiceConfig(
                        voice_name=settings.get("TTS_VOICE", "Kore"),
                    )
                )
            ),
        )
        
        response = client.models.generate_content(
            model=settings.get("GEMINI_TTS_MODEL"),
            contents=full_content_prompt,
            config=tts_config,
        )
        
        pcm_data = response.candidates[0].content.parts[0].inline_data.data
        if not pcm_data:
            raise ValueError("No audio data was generated by the API.")

        buffer = io.BytesIO()
        with wave.open(buffer, 'wb') as wf:
            wf.setnchannels(1)
            wf.setsampwidth(2)
            wf.setframerate(24000)
            wf.writeframes(pcm_data)
        
        wav_data = buffer.getvalue()

        # --- שליחת קובץ ה-WAV לכתובת דינמית ---
        dynamic_webhook_url = base_success_url.replace("{{PHONE_NUMBER}}", phone_number)
        
        file_name = f"{phone_number}.wav"
        files = {'file': (file_name, wav_data, 'audio/wav')}
        payload = {'phone_number': phone_number}

        print(f"Sending audio file to DYNAMIC success webhook: {dynamic_webhook_url}")
        post_response = requests.post(dynamic_webhook_url, files=files, data=payload, timeout=30)
        post_response.raise_for_status()

        print(f"Audio file for {phone_number} sent successfully.")

        # --- לוגיקה חדשה: שליחת Callback משני ---
        callback_url_template = settings.get("CALLBACK_URL")
        if callback_url_template and short_text:
            print(f"Preparing to send secondary callback for {phone_number}.")
            try:
                # החלפת כל ה-Placeholders האפשריים
                dynamic_callback_url = callback_url_template.replace("{{PHONE_NUMBER}}", phone_number)
                dynamic_callback_url = dynamic_callback_url.replace("{{SHORT_TEXT}}", short_text)

                callback_payload = {
                    "phone_number": phone_number,
                    "short_text": short_text
                }
                
                print(f"Sending callback to: {dynamic_callback_url}")
                callback_response = requests.post(dynamic_callback_url, json=callback_payload, timeout=20)
                callback_response.raise_for_status()
                print(f"Callback for {phone_number} sent successfully.")

            except Exception as callback_exc:
                # כישלון בשליחת ה-callback לא יכשיל את כל המשימה, רק יתריע בלוג
                print(f"⚠️ WARNING: Failed to send callback for {phone_number}. Error: {callback_exc}")

        return {"status": "success", "phone_number": phone_number, "callback_sent": bool(callback_url_template and short_text)}

    except Exception as exc:
        # --- לוגיקת טיפול בשגיאות (ללא שינוי) ---
        print(f"Task for {phone_number} failed. Attempt {self.request.retries + 1} of {self.max_retries}. Error: {str(exc)}")
        try:
            self.retry(exc=exc)
        except MaxRetriesExceededError:
            print(f"Max retries exceeded for task {self.request.id} ({phone_number}). Sending error notification.")
            error_url = settings.get("ERROR_WEBHOOK_URL")
            if error_url:
                try:
                    error_payload = {
                        "task_id": self.request.id,
                        "phone_number": phone_number,
                        "original_text": text,
                        "error_message": f"Failed after {self.max_retries} retries: {str(exc)}"
                    }
                    requests.post(error_url, json=error_payload, timeout=10)
                except Exception as webhook_exc:
                    print(f"Failed to send error notification webhook: {str(webhook_exc)}")
            
            return {"status": "failed", "phone_number": phone_number, "error": str(exc)}