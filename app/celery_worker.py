import os
import json
import redis
import requests
import google.generativeai as genai
from google.generativeai import types # <<< ייבוא חדש ונחוץ
from celery import Celery
from celery.exceptions import MaxRetriesExceededError

# --- Configuration ---
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
SETTINGS_KEY = "tts_settings"

redis_client = redis.from_url(REDIS_URL, decode_responses=True)

def load_settings():
    """טוען הגדרות מ-Redis או ממשתני הסביבה כברירת מחדל"""
    settings_json = redis_client.get(SETTINGS_KEY)
    if settings_json:
        return json.loads(settings_json)
    else:
        # Fallback to environment variables with new model default
        return {
            "GEMINI_API_KEY": os.getenv("GEMINI_API_KEY", ""),
            "GEMINI_TTS_MODEL": os.getenv("GEMINI_TTS_MODEL", "gemini-2.5-flash-preview-tts"), # <--- מודל ברירת מחדל חדש
            "TTS_VOICE": os.getenv("TTS_VOICE", "Kore"), # <--- קול ברירת מחדל חדש
            "TTS_PROMPT": os.getenv("TTS_PROMPT", ""),
            "SUCCESS_WEBHOOK_URL": os.getenv("SUCCESS_WEBHOOK_URL", ""),
            "ERROR_WEBHOOK_URL": os.getenv("ERROR_WEBHOOK_URL", "")
        }

celery_app = Celery("app.celery_worker", broker=REDIS_URL)

@celery_app.task(bind=True, max_retries=3, default_retry_delay=60, acks_late=True)
def generate_audio_task(self, text: str, phone_number: str):
    """
    משימת Celery לייצור קובץ שמע באמצעות השיטה החדשה של Gemini 2.5 TTS.
    """
    print(f"Starting audio generation task for: {phone_number} using new Gemini 2.5 method.")
    settings = load_settings()
    
    try:
        api_key = settings.get("GEMINI_API_KEY")
        success_url = settings.get("SUCCESS_WEBHOOK_URL")
        if not api_key or not success_url:
            raise ValueError("API Key or Success Webhook URL are not configured.")

        # Configure the client globally
        genai.configure(api_key=api_key)
        # The new documentation uses a client instance
        client = genai.Client()

        # --- שלב 1: בניית התוכן והקונפיגורציה לפי התיעוד החדש ---
        
        # 1.1 בניית ההנחיה המלאה (סגנון + טקסט)
        prompt = settings.get("TTS_PROMPT", "")
        full_content_prompt = f"{prompt}: {text}" if prompt else text
        
        print(f"Generating audio with full prompt: '{full_content_prompt}'")

        # 1.2 בניית אובייקט הקונפיגורציה
        tts_config = types.GenerateContentConfig(
            response_modalities=["AUDIO"],
            speech_config=types.SpeechConfig(
                voice_config=types.VoiceConfig(
                    prebuilt_voice_config=types.PrebuiltVoiceConfig(
                        voice_name=settings.get("TTS_VOICE", "Kore"), # שימוש בקול מההגדרות
                    )
                )
            ),
        )

        # --- שלב 2: קריאה ל-API בשיטה החדשה ---
        response = client.models.generate_content(
            model=settings.get("GEMINI_TTS_MODEL"), # שימוש במודל מההגדרות
            contents=full_content_prompt,
            config=tts_config,
        )

        # --- שלב 3: חילוץ המידע הבינארי מהתגובה המורכבת ---
        audio_data = response.candidates[0].content.parts[0].inline_data.data

        if not audio_data:
            raise ValueError("No audio data was generated by the API.")

        # --- שלב 4: שליחת הקובץ ל-Webhook (ללא שינוי) ---
        file_name = f"{phone_number}.mp3"
        # Note: The output is PCM data, often saved as .wav. For mp3, conversion might be needed.
        # However, we will send it as mpeg and let the receiving end handle it.
        files = {'file': (file_name, audio_data, 'audio/mpeg')}
        payload = {'phone_number': phone_number}

        print(f"Sending audio file to success webhook: {success_url}")
        post_response = requests.post(success_url, files=files, data=payload, timeout=30)
        post_response.raise_for_status()

        print(f"Task for {phone_number} completed successfully.")
        return {"status": "success", "phone_number": phone_number}

    except Exception as exc:
        print(f"Task for {phone_number} failed. Attempt {self.request.retries + 1} of {self.max_retries}. Error: {str(exc)}")
        try:
            self.retry(exc=exc)
        except MaxRetriesExceededError:
            # לוגיקת השגיאות נשארת זהה
            print(f"Max retries exceeded for task {self.request.id} ({phone_number}). Sending error notification.")
            error_url = settings.get("ERROR_WEBHOOK_URL")
            if error_url:
                try:
                    error_payload = {
                        "task_id": self.request.id,
                        "phone_number": phone_number,
                        "original_text": text,
                        "error_message": f"Failed after {self.max_retries} retries: {str(exc)}"
                    }
                    requests.post(error_url, json=error_payload, timeout=10)
                except Exception as webhook_exc:
                    print(f"Failed to send error notification webhook: {str(webhook_exc)}")
            
            return {"status": "failed", "phone_number": phone_number, "error": str(exc)}